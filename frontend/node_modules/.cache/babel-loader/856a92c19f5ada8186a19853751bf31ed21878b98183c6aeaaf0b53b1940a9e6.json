{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nexport default {\n  name: 'AudioRecorder',\n  emits: ['recognition-complete'],\n  // 显式声明组件发出的事件\n  data() {\n    return {\n      isRecording: false,\n      mediaRecorder: null,\n      audioChunks: [],\n      audioContext: null\n    };\n  },\n  methods: {\n    async toggleRecording() {\n      if (this.isRecording) {\n        console.log('停止录音...');\n        this.stopRecording();\n      } else {\n        console.log('开始录音...');\n        await this.startRecording();\n      }\n    },\n    async startRecording() {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            channelCount: 1,\n            sampleRate: 16000,\n            sampleSize: 16,\n            echoCancellation: false,\n            // 关闭回声消除\n            noiseSuppression: false,\n            // 关闭噪声抑制\n            autoGainControl: false // 关闭自动增益\n          }\n        });\n\n        // 使用更兼容的格式\n        const mimeType = 'audio/webm';\n        this.mediaRecorder = new MediaRecorder(stream, {\n          mimeType: mimeType,\n          audioBitsPerSecond: 256000 // 提高比特率\n        });\n        this.audioChunks = [];\n        this.mediaRecorder.ondataavailable = event => {\n          this.audioChunks.push(event.data);\n        };\n        this.mediaRecorder.onstop = async () => {\n          try {\n            const audioBlob = new Blob(this.audioChunks, {\n              type: mimeType\n            });\n            console.log('原始音频大小:', audioBlob.size);\n\n            // 转换为WAV格式\n            const wavBlob = await this.convertToWav(audioBlob);\n            console.log('WAV音频大小:', wavBlob.size);\n            await this.sendAudioToServer(wavBlob);\n          } catch (error) {\n            console.error('音频处理失败:', error);\n            this.$emit('recognition-complete', '音频处理失败，请重试');\n          }\n        };\n\n        // 设置更频繁的数据收集\n        this.mediaRecorder.start(100); // 每100ms收集一次数据\n        this.isRecording = true;\n      } catch (error) {\n        console.error('录音失败:', error);\n        alert('无法访问麦克风，请确保已授予麦克风访问权限。');\n      }\n    },\n    // 将音频数据转换为WAV格式\n    async convertToWav(audioBlob) {\n      try {\n        const arrayBuffer = await audioBlob.arrayBuffer();\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)({\n          sampleRate: 16000 // 确保采样率为16000Hz\n        });\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        console.log('音频信息:', {\n          sampleRate: audioBuffer.sampleRate,\n          numberOfChannels: audioBuffer.numberOfChannels,\n          duration: audioBuffer.duration\n        });\n\n        // 创建WAV文件\n        const wavBuffer = this.audioBufferToWav(audioBuffer);\n        return new Blob([wavBuffer], {\n          type: 'audio/wav'\n        });\n      } catch (error) {\n        console.error('音频转换失败:', error);\n        throw error;\n      }\n    },\n    // 将AudioBuffer转换为WAV格式\n    audioBufferToWav(buffer) {\n      const numOfChan = buffer.numberOfChannels;\n      const length = buffer.length * numOfChan * 2;\n      const buffer2 = new ArrayBuffer(44 + length);\n      const view = new DataView(buffer2);\n      const channels = [];\n      let offset = 0;\n      let pos = 0;\n\n      // 写入WAV文件头\n      this.writeString(view, 0, 'RIFF');\n      view.setUint32(4, 36 + length, true);\n      this.writeString(view, 8, 'WAVE');\n      this.writeString(view, 12, 'fmt ');\n      view.setUint32(16, 16, true);\n      view.setUint16(20, 1, true); // PCM格式\n      view.setUint16(22, numOfChan, true);\n      view.setUint32(24, 16000, true); // 采样率固定为16000Hz\n      view.setUint32(28, 16000 * 2 * numOfChan, true); // 字节率\n      view.setUint16(32, numOfChan * 2, true); // 块对齐\n      view.setUint16(34, 16, true); // 位深度\n      this.writeString(view, 36, 'data');\n      view.setUint32(40, length, true);\n\n      // 写入音频数据\n      for (let i = 0; i < buffer.numberOfChannels; i++) {\n        channels.push(buffer.getChannelData(i));\n      }\n      while (pos < buffer.length) {\n        for (let i = 0; i < numOfChan; i++) {\n          let sample = Math.max(-1, Math.min(1, channels[i][pos]));\n          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;\n          view.setInt16(44 + offset, sample, true);\n          offset += 2;\n        }\n        pos++;\n      }\n      return buffer2;\n    },\n    writeString(view, offset, string) {\n      for (let i = 0; i < string.length; i++) {\n        view.setUint8(offset + i, string.charCodeAt(i));\n      }\n    },\n    stopRecording() {\n      if (this.mediaRecorder && this.isRecording) {\n        this.mediaRecorder.stop();\n        this.isRecording = false;\n        this.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n      }\n    },\n    async sendAudioToServer(audioBlob) {\n      try {\n        const formData = new FormData();\n        formData.append('audio', audioBlob, 'recording.wav');\n        console.log('正在发送音频到服务器...');\n        const response = await fetch('/api/audio/recognize', {\n          method: 'POST',\n          body: formData\n        });\n        const result = await response.json();\n        console.log('服务器返回结果:', result);\n        if (!response.ok) {\n          throw new Error(result.error || '服务器错误');\n        }\n        if (result.success) {\n          // 发出识别完成事件，将识别结果发送给父组件\n          console.log('[AudioRecorder] 发送识别结果到父组件:', result.text);\n\n          // 尝试多种方式触发事件\n          this.$emit('recognition-complete', result.text);\n          console.log('[AudioRecorder] 事件已发出');\n\n          // 延迟100ms后再次发送事件，确保Vue更新周期捕获它\n          setTimeout(() => {\n            console.log('[AudioRecorder] 延迟发送事件');\n            this.$emit('recognition-complete', result.text);\n          }, 100);\n        } else {\n          console.error('语音识别失败:', result.error);\n          this.$emit('recognition-complete', '识别失败，请重试');\n        }\n      } catch (error) {\n        console.error('发送音频文件失败:', error);\n        this.$emit('recognition-complete', '识别失败，请重试');\n      }\n    },\n    async stopRecording2() {\n      try {\n        console.log('正在发送音频到服务器2...');\n        const response = await fetch('/api/audio/stop_and_recognize', {\n          method: 'POST'\n        });\n        const result = await response.json();\n        console.log('服务器返回结果:', result);\n        if (!response.ok) {\n          throw new Error(result.error || '服务器错误');\n        }\n        if (result.success) {\n          // 发出识别完成事件，将识别结果发送给父组件\n          console.log('[AudioRecorder] 发送识别结果到父组件:', result.text);\n\n          // 尝试多种方式触发事件\n          this.$emit('recognition-complete', result.text);\n          console.log('[AudioRecorder] 事件已发出');\n\n          // 延迟100ms后再次发送事件，确保Vue更新周期捕获它\n          setTimeout(() => {\n            console.log('[AudioRecorder] 延迟发送事件');\n            this.$emit('recognition-complete', result.text);\n          }, 100);\n        } else {\n          console.error('语音识别失败:', result.error);\n          this.$emit('recognition-complete', '识别失败，请重试');\n        }\n      } catch (error) {\n        console.error('发送音频文件失败:', error);\n        this.$emit('recognition-complete', '识别失败，请重试');\n      }\n    },\n    async startRecording2() {\n      try {\n        console.log('正在开始录音音频到服务器2...');\n        const response = await fetch('/api/audio/stop_and_recognize', {\n          method: 'POST'\n        });\n        const result = await response.json();\n        console.log('服务器返回结果:', result);\n        if (!response.ok) {\n          throw new Error(result.error || '服务器错误');\n        }\n        if (result.success) {\n          // 发出识别完成事件，将识别结果发送给父组件\n          console.log('[AudioRecorder] 发送识别结果到父组件:', result.text);\n\n          // 尝试多种方式触发事件\n          this.$emit('recognition-complete', result.text);\n          console.log('[AudioRecorder] 事件已发出');\n\n          // 延迟100ms后再次发送事件，确保Vue更新周期捕获它\n          setTimeout(() => {\n            console.log('[AudioRecorder] 延迟发送事件');\n            this.$emit('recognition-complete', result.text);\n          }, 100);\n        } else {\n          console.error('语音识别失败:', result.error);\n          this.$emit('recognition-complete', '识别失败，请重试');\n        }\n      } catch (error) {\n        console.error('发送音频文件失败:', error);\n        this.$emit('recognition-complete', '识别失败，请重试');\n      }\n    }\n  }\n};","map":{"version":3,"names":["name","emits","data","isRecording","mediaRecorder","audioChunks","audioContext","methods","toggleRecording","console","log","stopRecording","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","channelCount","sampleRate","sampleSize","echoCancellation","noiseSuppression","autoGainControl","mimeType","MediaRecorder","audioBitsPerSecond","ondataavailable","event","push","onstop","audioBlob","Blob","type","size","wavBlob","convertToWav","sendAudioToServer","error","$emit","start","alert","arrayBuffer","window","AudioContext","webkitAudioContext","audioBuffer","decodeAudioData","numberOfChannels","duration","wavBuffer","audioBufferToWav","buffer","numOfChan","length","buffer2","ArrayBuffer","view","DataView","channels","offset","pos","writeString","setUint32","setUint16","i","getChannelData","sample","Math","max","min","setInt16","string","setUint8","charCodeAt","stop","getTracks","forEach","track","formData","FormData","append","response","fetch","method","body","result","json","ok","Error","success","text","setTimeout","stopRecording2","startRecording2"],"sources":["D:\\HCI_FINAL\\new_copy\\frontend\\src\\components\\AudioRecorder.vue"],"sourcesContent":["<template>\r\n  <div class=\"audio-recorder\">\r\n    <button \r\n      class=\"icon-button\" \r\n      :class=\"{ recording: isRecording }\"\r\n      @click=\"toggleRecording\"\r\n    >\r\n      <img \r\n        :src=\"require('@/assets/image/mic-icon.png')\" \r\n        alt=\"录音\" \r\n        class=\"button-icon\"\r\n      >\r\n    </button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'AudioRecorder',\r\n  emits: ['recognition-complete'],  // 显式声明组件发出的事件\r\n  data() {\r\n    return {\r\n      isRecording: false,\r\n      mediaRecorder: null,\r\n      audioChunks: [],\r\n      audioContext: null,\r\n    }\r\n  },\r\n  methods: {\r\n    async toggleRecording() {\r\n      if (this.isRecording) {\r\n        console.log('停止录音...');\r\n        this.stopRecording();\r\n      } else {\r\n        console.log('开始录音...');\r\n        await this.startRecording();\r\n      }\r\n    },\r\n\r\n    async startRecording() {\r\n      try {\r\n        const stream = await navigator.mediaDevices.getUserMedia({ \r\n          audio: {\r\n            channelCount: 1,\r\n            sampleRate: 16000,\r\n            sampleSize: 16,\r\n            echoCancellation: false,  // 关闭回声消除\r\n            noiseSuppression: false,  // 关闭噪声抑制\r\n            autoGainControl: false    // 关闭自动增益\r\n          } \r\n        });\r\n        \r\n        // 使用更兼容的格式\r\n        const mimeType = 'audio/webm';\r\n        this.mediaRecorder = new MediaRecorder(stream, {\r\n          mimeType: mimeType,\r\n          audioBitsPerSecond: 256000  // 提高比特率\r\n        });\r\n        \r\n        this.audioChunks = [];\r\n\r\n        this.mediaRecorder.ondataavailable = (event) => {\r\n          this.audioChunks.push(event.data);\r\n        };\r\n\r\n        this.mediaRecorder.onstop = async () => {\r\n          try {\r\n            const audioBlob = new Blob(this.audioChunks, { type: mimeType });\r\n            console.log('原始音频大小:', audioBlob.size);\r\n            \r\n            // 转换为WAV格式\r\n            const wavBlob = await this.convertToWav(audioBlob);\r\n            console.log('WAV音频大小:', wavBlob.size);\r\n            \r\n            await this.sendAudioToServer(wavBlob);\r\n          } catch (error) {\r\n            console.error('音频处理失败:', error);\r\n            this.$emit('recognition-complete', '音频处理失败，请重试');\r\n          }\r\n        };\r\n\r\n        // 设置更频繁的数据收集\r\n        this.mediaRecorder.start(100);  // 每100ms收集一次数据\r\n        this.isRecording = true;\r\n      } catch (error) {\r\n        console.error('录音失败:', error);\r\n        alert('无法访问麦克风，请确保已授予麦克风访问权限。');\r\n      }\r\n    },\r\n\r\n    // 将音频数据转换为WAV格式\r\n    async convertToWav(audioBlob) {\r\n      try {\r\n        const arrayBuffer = await audioBlob.arrayBuffer();\r\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)({\r\n          sampleRate: 16000  // 确保采样率为16000Hz\r\n        });\r\n        \r\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n        console.log('音频信息:', {\r\n          sampleRate: audioBuffer.sampleRate,\r\n          numberOfChannels: audioBuffer.numberOfChannels,\r\n          duration: audioBuffer.duration\r\n        });\r\n        \r\n        // 创建WAV文件\r\n        const wavBuffer = this.audioBufferToWav(audioBuffer);\r\n        return new Blob([wavBuffer], { type: 'audio/wav' });\r\n      } catch (error) {\r\n        console.error('音频转换失败:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // 将AudioBuffer转换为WAV格式\r\n    audioBufferToWav(buffer) {\r\n      const numOfChan = buffer.numberOfChannels;\r\n      const length = buffer.length * numOfChan * 2;\r\n      const buffer2 = new ArrayBuffer(44 + length);\r\n      const view = new DataView(buffer2);\r\n      const channels = [];\r\n      let offset = 0;\r\n      let pos = 0;\r\n\r\n      // 写入WAV文件头\r\n      this.writeString(view, 0, 'RIFF');\r\n      view.setUint32(4, 36 + length, true);\r\n      this.writeString(view, 8, 'WAVE');\r\n      this.writeString(view, 12, 'fmt ');\r\n      view.setUint32(16, 16, true);\r\n      view.setUint16(20, 1, true);  // PCM格式\r\n      view.setUint16(22, numOfChan, true);\r\n      view.setUint32(24, 16000, true);  // 采样率固定为16000Hz\r\n      view.setUint32(28, 16000 * 2 * numOfChan, true);  // 字节率\r\n      view.setUint16(32, numOfChan * 2, true);  // 块对齐\r\n      view.setUint16(34, 16, true);  // 位深度\r\n      this.writeString(view, 36, 'data');\r\n      view.setUint32(40, length, true);\r\n\r\n      // 写入音频数据\r\n      for (let i = 0; i < buffer.numberOfChannels; i++) {\r\n        channels.push(buffer.getChannelData(i));\r\n      }\r\n\r\n      while (pos < buffer.length) {\r\n        for (let i = 0; i < numOfChan; i++) {\r\n          let sample = Math.max(-1, Math.min(1, channels[i][pos]));\r\n          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;\r\n          view.setInt16(44 + offset, sample, true);\r\n          offset += 2;\r\n        }\r\n        pos++;\r\n      }\r\n\r\n      return buffer2;\r\n    },\r\n\r\n    writeString(view, offset, string) {\r\n      for (let i = 0; i < string.length; i++) {\r\n        view.setUint8(offset + i, string.charCodeAt(i));\r\n      }\r\n    },\r\n\r\n    stopRecording() {\r\n      if (this.mediaRecorder && this.isRecording) {\r\n        this.mediaRecorder.stop();\r\n        this.isRecording = false;\r\n        this.mediaRecorder.stream.getTracks().forEach(track => track.stop());\r\n      }\r\n    },\r\n\r\n    async sendAudioToServer(audioBlob) {\r\n      try {\r\n        const formData = new FormData();\r\n        formData.append('audio', audioBlob, 'recording.wav');\r\n\r\n        console.log('正在发送音频到服务器...');\r\n        const response = await fetch('/api/audio/recognize', {\r\n          method: 'POST',\r\n          body: formData\r\n        });\r\n\r\n        const result = await response.json();\r\n        console.log('服务器返回结果:', result);\r\n        \r\n        if (!response.ok) {\r\n          throw new Error(result.error || '服务器错误');\r\n        }\r\n\r\n        if (result.success) {\r\n          // 发出识别完成事件，将识别结果发送给父组件\r\n          console.log('[AudioRecorder] 发送识别结果到父组件:', result.text);\r\n          \r\n          // 尝试多种方式触发事件\r\n          this.$emit('recognition-complete', result.text);\r\n          console.log('[AudioRecorder] 事件已发出');\r\n          \r\n          // 延迟100ms后再次发送事件，确保Vue更新周期捕获它\r\n          setTimeout(() => {\r\n            console.log('[AudioRecorder] 延迟发送事件');\r\n            this.$emit('recognition-complete', result.text);\r\n          }, 100);\r\n        } else {\r\n          console.error('语音识别失败:', result.error);\r\n          this.$emit('recognition-complete', '识别失败，请重试');\r\n        }\r\n      } catch (error) {\r\n        console.error('发送音频文件失败:', error);\r\n        this.$emit('recognition-complete', '识别失败，请重试');\r\n      }\r\n    },\r\n\r\n    async stopRecording2() {\r\n      try {\r\n        console.log('正在发送音频到服务器2...');\r\n        const response = await fetch('/api/audio/stop_and_recognize', {\r\n          method: 'POST',\r\n        });\r\n\r\n        const result = await response.json();\r\n        console.log('服务器返回结果:', result);\r\n        \r\n        if (!response.ok) {\r\n          throw new Error(result.error || '服务器错误');\r\n        }\r\n\r\n        if (result.success) {\r\n          // 发出识别完成事件，将识别结果发送给父组件\r\n          console.log('[AudioRecorder] 发送识别结果到父组件:', result.text);\r\n          \r\n          // 尝试多种方式触发事件\r\n          this.$emit('recognition-complete', result.text);\r\n          console.log('[AudioRecorder] 事件已发出');\r\n          \r\n          // 延迟100ms后再次发送事件，确保Vue更新周期捕获它\r\n          setTimeout(() => {\r\n            console.log('[AudioRecorder] 延迟发送事件');\r\n            this.$emit('recognition-complete', result.text);\r\n          }, 100);\r\n        } else {\r\n          console.error('语音识别失败:', result.error);\r\n          this.$emit('recognition-complete', '识别失败，请重试');\r\n        }\r\n      } catch (error) {\r\n        console.error('发送音频文件失败:', error);\r\n        this.$emit('recognition-complete', '识别失败，请重试');\r\n      }\r\n    },\r\n    async startRecording2() {\r\n      try {\r\n        console.log('正在开始录音音频到服务器2...');\r\n        const response = await fetch('/api/audio/stop_and_recognize', {\r\n          method: 'POST',\r\n        });\r\n\r\n        const result = await response.json();\r\n        console.log('服务器返回结果:', result);\r\n        \r\n        if (!response.ok) {\r\n          throw new Error(result.error || '服务器错误');\r\n        }\r\n\r\n        if (result.success) {\r\n          // 发出识别完成事件，将识别结果发送给父组件\r\n          console.log('[AudioRecorder] 发送识别结果到父组件:', result.text);\r\n          \r\n          // 尝试多种方式触发事件\r\n          this.$emit('recognition-complete', result.text);\r\n          console.log('[AudioRecorder] 事件已发出');\r\n          \r\n          // 延迟100ms后再次发送事件，确保Vue更新周期捕获它\r\n          setTimeout(() => {\r\n            console.log('[AudioRecorder] 延迟发送事件');\r\n            this.$emit('recognition-complete', result.text);\r\n          }, 100);\r\n        } else {\r\n          console.error('语音识别失败:', result.error);\r\n          this.$emit('recognition-complete', '识别失败，请重试');\r\n        }\r\n      } catch (error) {\r\n        console.error('发送音频文件失败:', error);\r\n        this.$emit('recognition-complete', '识别失败，请重试');\r\n      }\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.audio-recorder {\r\n  display: inline-block;\r\n}\r\n\r\n.icon-button {\r\n  width: 40px;\r\n  height: 40px;\r\n  cursor: pointer;\r\n  background: none;\r\n  border: none;\r\n  padding: 8px;\r\n  transition: transform 0.2s;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  position: relative;\r\n  z-index: 1;\r\n}\r\n\r\n.button-icon {\r\n  width: 24px;\r\n  height: 24px;\r\n  object-fit: contain;\r\n}\r\n\r\n.icon-button:hover {\r\n  transform: scale(1.1);\r\n}\r\n\r\n.icon-button.recording {\r\n  animation: pulse 1.5s infinite;\r\n  filter: invert(48%) sepia(79%) saturate(2476%) hue-rotate(330deg) !important;\r\n}\r\n\r\n@keyframes pulse {\r\n  0% {\r\n    transform: scale(1);\r\n  }\r\n  50% {\r\n    transform: scale(1.05);\r\n  }\r\n  100% {\r\n    transform: scale(1);\r\n  }\r\n}\r\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}